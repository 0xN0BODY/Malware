import idautils
import idaapi
import rc4


DECRYPT_STR_FUNC_EA = 0x406461

DECRYPT_STR_FUNC_NAME = 'decrypt_str'
DECRYPT_STR_FUNC_TYPE = \
    'void * __cdecl decrypt_str(void *enc_data, unsigned int pos, ' \
    'unsigned int key_len, unsigned int data_len, void *dest)'


def get_arg_val(arg_ea):

    inst = DecodeInstruction(arg_ea)
    if (inst.itype != idaapi.NN_push):
        return None

    if (inst.ops[0].type == o_imm):
        return inst.ops[0].value

    if (inst.ops[0].type != o_reg):
        return None

    reg = inst.ops[0].reg

    min_ea = get_func_attr(arg_ea, FUNCATTR_START)

    ea = ida_bytes.prev_head(arg_ea, min_ea)

    while (ea != BADADDR):

        inst = DecodeInstruction(ea)

        if (inst.ops[0].type == o_reg) and (inst.ops[0].reg == reg):

            if (inst.itype == idaapi.NN_mov):
                # mov reg, imm
                if (inst.ops[1].type == o_imm):
                    return inst.ops[1].value
                break

            elif (inst.itype == idaapi.NN_pop):
                # pop reg, push imm
                ea2 = ida_bytes.prev_head(ea, min_ea)
                if (ea2 == BADADDR):
                    break

                inst = DecodeInstruction(ea2)
                if (inst.itype == idaapi.NN_push):
                    if (inst.ops[0].type == o_imm):
                        return inst.ops[0].value
                    break

        ea = ida_bytes.prev_head(ea, min_ea)

    return None


def decrypt_str(call_ea):

    arg_addrs = idaapi.get_arg_addrs(call_ea)
    if (arg_addrs is None):
        return None

    arg_vals = list(range(4));

    for i in range(4):
        arg_vals[i] = get_arg_val(arg_addrs[i])
        if arg_vals[i] is None:
            return None

    enc_data_ea = arg_vals[0] + arg_vals[1]
    key = ida_bytes.get_bytes(enc_data_ea, arg_vals[2])
    enc_data = ida_bytes.get_bytes(enc_data_ea + arg_vals[2], arg_vals[3])

    dec_data = rc4.rc4(enc_data, key)

    if (len(dec_data) == 0):
        return ''

    if (len(dec_data) & 1) or (dec_data[1] != 0):
        return dec_data.decode()

    return dec_data.decode('UTF-16')


ida_name.set_name(DECRYPT_STR_FUNC_EA, DECRYPT_STR_FUNC_NAME)

if SetType(DECRYPT_STR_FUNC_EA, DECRYPT_STR_FUNC_TYPE) == 0:
    raise Exception('Failed to set type of ' + DECRYPT_STR_FUNC_NAME + '.')

auto_wait()

enc_str_count = 0
dec_str_count = 0

for xref in CodeRefsTo(DECRYPT_STR_FUNC_EA, 1):

    enc_str_count += 1

    dec_str = decrypt_str(xref)

    if (dec_str is None):
        print('%08X: Failed to decrypt string.' % xref)
        continue

    s = dec_str.encode('unicode_escape').decode().replace('\"', '\\"')
    set_cmt(xref, '\"' + s + '\"', 1)

    dec_str_count += 1

print(str(enc_str_count) + ' string(s) found.')
print(str(dec_str_count) + ' string(s) decrypted.')
