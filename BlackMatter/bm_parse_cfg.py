"""
BlackMatter configuration data parser.

GitHub: https://github.com/rivitna/
E-mail: rivitna@gmail.com
"""

import sys
import io
import os
import errno
import struct
import base64
import aplib
import bm_dec


# BlackMatter versions
BM_MIN_VER = 0x102
BM_MAX_VER = 0x300
BM_DEF_VER = 0x300

# BlackMatter configuration data section name
CFG_SECTION_NAME = b'.rsrc'

RSA_PUB_KEY_SIZE = 0x80
BOT_COMPANY_SIZE = 0x10
AES_KEY_SIZE = 0x10

# BlackMatter flags
FLAGS = [
    ( 'encrypt additional blocks in large files',                 0x102 ),
    ( 'logon with cfg user accounts',                             0x102 ),
    ( 'mount volumes and (v1.4 or above) encrypt Exchange files', 0x102 ),
    ( 'encrypt net share files',                                  0x102 ),
    ( 'kill processes',                                           0x102 ),
    ( 'stop and kill services',                                   0x102 ),
    ( 'create mutex',                                             0x102 ),
    ( 'print ransom note',                                        0x109 ),
    ( 'c&c communication',                                        0x102 ),
]

# BlackMatter data fields
DATA_FIELDS = [
    ( 'dir_names',      0x102, False ),
    ( 'file_names',     0x102, False ),
    ( 'file_exts',      0x102, False ),
    ( 'computer_names', 0x109, False ),
    ( 'unknown0',       0x102, False ),
    ( 'processes',      0x102, False ),
    ( 'services',       0x102, False ),
    ( 'c&c',            0x102, False ),
    ( 'accounts',       0x102, True  ),
    ( 'ransom_note',    0x102, True  ),
]


def get_bm_info(file_data):
    """
    Get BlackMatter sample information:
        - configuration data position;
        - version (None - unknown version).
    """

    mz_sign, = struct.unpack_from('<H', file_data, 0)
    if (mz_sign != 0x5A4D):
        return None

    nt_hdr_pos, = struct.unpack_from('<L', file_data, 0x3C)

    pe_sign, = struct.unpack_from('<L', file_data, nt_hdr_pos)
    if (pe_sign != 0x00004550):
        return None

    # Parse PE header
    img_hdr_pos = nt_hdr_pos + 4
    num_sections, = struct.unpack_from('<H', file_data, img_hdr_pos + 2)
    opt_hdr_pos = img_hdr_pos + 0x14
    opt_hdr_size, = struct.unpack_from('<H', file_data, img_hdr_pos + 0x10)
    nt_hdr_size = 4 + 0x14 + opt_hdr_size
    first_section_hdr_pos = nt_hdr_pos + nt_hdr_size
    entry_point, = struct.unpack_from('<L', file_data, opt_hdr_pos + 0x10)
    opt_hdr_magic, = struct.unpack_from('<H', file_data, opt_hdr_pos)
    is_x64 = (opt_hdr_magic == 0x20B)
    if is_x64:
        image_base, = struct.unpack_from('<Q', file_data, opt_hdr_pos + 0x18)
    else:
        image_base, = struct.unpack_from('<L', file_data, opt_hdr_pos + 0x1C)

    cfg_pos = None
    code_pos = None

    # Enumerate PE sections
    pos = first_section_hdr_pos

    for i in range(num_sections):

        s_name = file_data[pos : pos + 8]
        i = s_name.find(0)
        if (i >= 0):
            s_name = s_name[:i]

        s_vsize, s_rva, s_psize, s_pos = \
            struct.unpack_from('<4L', file_data, pos + 8)

        if (s_pos != 0):
            if (s_rva < entry_point < s_rva + s_vsize):
                code_pos = s_pos
                code_rva = s_rva
                code_size = s_vsize
                if (code_size == 0) or (code_size > s_psize):
                    code_size = s_psize
            elif (s_name == CFG_SECTION_NAME):
                cfg_pos = s_pos

        pos += 0x28

    if cfg_pos is None:
        return None

    # No PE32+ samples yet
    if (code_pos is None) or is_x64:
        return cfg_pos, None

    code_data  = file_data[code_pos : code_pos + code_size]

    for pos in range(0, code_size, 4):
        enc_ver, = struct.unpack_from('<L', code_data, pos)
        if (enc_ver != 0xCCCCCCCC):
            break
    else:
        return cfg_pos, None

    # mov  eax, ds:enc_version
    # xor  eax, XOR_MASK
    enc_ver_va = image_base + code_rva + pos
    pattern1 = b'\xA1' + struct.pack('<L', enc_ver_va) + b'\x35'
    pattern1_len = len(pattern1)
    # shr  eax, 10h
    pattern2 = b'\xC1\xE8\x10'
    pattern2_len = len(pattern2)

    # Find patterns to determine XOR mask
    while True:

        pos = code_data.find(pattern1, pos)
        if (pos < 0):
            return cfg_pos, None

        pos += pattern1_len

        if code_data[pos + 4 : pos + 4 + pattern2_len] == pattern2:
            break

    xor_mask, = struct.unpack_from('<L', code_data, pos)

    ver = (enc_ver ^ xor_mask) >> 16

    return cfg_pos, ver


def mkdirs(dir):
    """Create directory hierarchy."""

    try:
        os.makedirs(dir)

    except OSError as exception:
        if (exception.errno != errno.EEXIST):
            raise


def save_data_to_file(file_name, data):
    """Save binary data to file."""
    with io.open(file_name, 'wb') as f:
        f.write(data)

#
# Main
#
if len(sys.argv) != 2:
    print('Usage: '+ sys.argv[0] + ' filename')
    sys.exit(0)

file_name = sys.argv[1]

# Load file data
with io.open(file_name, 'rb') as f:
    file_data = f.read()

# Get BlackMatter sample information
info = get_bm_info(file_data)
if info is None:
    print('Error: BlackMatter configuration data not found.')
    sys.exit(1)

cfg_pos = info[0]
bm_ver = info[1]

if bm_ver is not None:
    print('version: %d.%d' % (bm_ver >> 8, bm_ver & 0xFF))
else:
    bm_ver = BM_DEF_VER
    print('Warning: BlackMatter unknown version. ' \
          'Use specifed default version (%d.%d)' %
              (bm_ver >> 8, bm_ver & 0xFF))

if (bm_ver < BM_MIN_VER) or (bm_ver > BM_MAX_VER):
    print('Warning: BlackMatter unsupported version.')

print()

print('configuration data position: %08X' % cfg_pos)

print()

dest_dir = os.path.abspath(os.path.dirname(file_name)) + '/cfg/'
mkdirs(dest_dir)

if (bm_ver < 0x200):

    rnd_seed, = struct.unpack_from('<L', file_data, cfg_pos)
    print(('rnd seed: %04X') % rnd_seed)

    cfg_pos += 4

    decrypt_func = bm_dec.decrypt32

else:

    rnd_seed, = struct.unpack_from('<Q', file_data, cfg_pos)
    print(('rnd seed: %08X') % rnd_seed)

    cfg_pos += 8

    if (bm_ver < 0x300):
        decrypt_func = bm_dec.decrypt2
    else:
        decrypt_func = bm_dec.decrypt3

pack_cfg_data_size, = struct.unpack_from('<L', file_data, cfg_pos)
print('compressed cfg data size: %d' % pack_cfg_data_size)

cfg_pos += 4

enc_cfg_data = file_data[cfg_pos : cfg_pos + pack_cfg_data_size]

pack_cfg_data = decrypt_func(enc_cfg_data, rnd_seed)

cfg_data = aplib.decompress(pack_cfg_data)

print('cfg data size: %d' % len(cfg_data))

save_data_to_file(dest_dir + 'cfg_data.bin', cfg_data)
print('cfg data saved to file.')

print()

pos = 0

rsa_pub_key = cfg_data[pos : pos + RSA_PUB_KEY_SIZE]
save_data_to_file(dest_dir + 'rsa_pub_key.bin', rsa_pub_key)
print('RSA public key saved to file.')

pos += RSA_PUB_KEY_SIZE

bot_company = cfg_data[pos : pos + BOT_COMPANY_SIZE]
print('bot_company: \"%.8x%.8x%.8x%.8x\"' % struct.unpack('>4L', bot_company))

save_data_to_file(dest_dir + 'bot_company.bin', bot_company)
print('bot_company saved to file.')

pos += BOT_COMPANY_SIZE

aes_key = cfg_data[pos : pos + AES_KEY_SIZE]
save_data_to_file(dest_dir + 'aes_key.bin', aes_key)
print('AES key saved to file.')

pos += AES_KEY_SIZE

print()

print('flags:')

for flag in FLAGS:

    if (bm_ver < flag[1]):
        continue

    print('%s: %s' % (flag[0], 'yes' if cfg_data[pos] != 0 else 'no'))

    pos += 1

print()

print('fields:')

data_pos = pos

for fld in DATA_FIELDS:

    if (bm_ver < fld[1]):
        continue

    ofs, = struct.unpack_from('<L', cfg_data, pos)
    if (ofs != 0):

        i = cfg_data.find(0, data_pos + ofs)
        if (i >= 0):
            b64_data = cfg_data[data_pos + ofs : i]
        else:
            b64_data = cfg_data[data_pos + ofs:]

        data = base64.decodebytes(b64_data)

        if fld[2]:
            data = decrypt_func(data, rnd_seed)

        save_data_to_file(dest_dir + fld[0] + '.bin', data)
        print(fld[0] + ' saved to file.')

    pos += 4

print()

if (bm_ver >= 0x109):
    ransom_hash, = struct.unpack_from('<L', cfg_data, pos)
    print('ransom note hash: %08X' % ransom_hash)
