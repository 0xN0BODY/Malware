"""
LockBit 3.0 configuration data parser.

GitHub: https://github.com/rivitna/
E-mail: rivitna@gmail.com
"""

import sys
import io
import os
import errno
import struct
import base64
import binascii
import json
import aplib
import lb3_dec
import lb3_hash


# Configuration data file position
# If None try detect automatically position
CFG_POS = None
# Encrypted helper code file position
ENC_HELPER_CODE_POS = 0x22BBB

# LockBit 3.0 configuration data section name
CFG_SECTION_NAME = b'.pdata'


RSA_PUB_KEY_SIZE = 0x80
UID_SIZE = 0x10
AES_KEY_SIZE = 0x10


# Settings
SETTING_UNKNOWN = 0
SETTING_BOOL = 1
SETTING_WORD = 2
SETTING_ENC_MODE = 3

# Encrypt modes
ENC_MODES = {
    0: "fast",
    1: "auto"
}

SETTINGS = [
    ( 'encrypt_mode',        SETTING_ENC_MODE ),
    ( 'encrypt_filename',    SETTING_BOOL ),
    ( 'impersonation',       SETTING_BOOL ),
    ( 'skip_hidden_folders', SETTING_BOOL ),
    ( 'language_check',      SETTING_BOOL ),
    ( 'local_disks',         SETTING_BOOL ),
    ( 'network_shares',      SETTING_BOOL ),
    ( 'kill_processes',      SETTING_BOOL ),
    ( 'kill_services',       SETTING_BOOL ),
    ( 'running_one',         SETTING_BOOL ),
    ( 'print_note',          SETTING_BOOL ),
    ( 'set_wallpaper',       SETTING_BOOL ),
    ( 'set_icons',           SETTING_BOOL ),
    ( 'send_report',         SETTING_BOOL ),
    ( 'self_destruct',       SETTING_BOOL ),
    ( 'kill_defender',       SETTING_BOOL ),
    ( 'wipe_freespace',      SETTING_BOOL ),
    ( 'psexec_netspread',    SETTING_BOOL ),
    ( 'gpo_netspread',       SETTING_BOOL ),
    ( 'gpo_ps_update',       SETTING_BOOL ),
    ( 'shutdown_system',     SETTING_BOOL ),
    ( 'delete_eventlogs',    SETTING_BOOL ),
    ( 'delete_gpo_delay',    SETTING_WORD ),
]


# Fields
FIELD_UNKNOWN = 0
FIELD_STRLIST = 1
FIELD_HASHLIST = 2
FIELD_TEXT = 3

FIELDS = [
    ( 'white_folders',   FIELD_HASHLIST, False ),
    ( 'white_files',     FIELD_HASHLIST, False ),
    ( 'white_extens',    FIELD_HASHLIST, False ),
    ( 'white_hosts',     FIELD_HASHLIST, False ),
    ( 'unknown',         FIELD_UNKNOWN,  False ),
    ( 'kill_processes',  FIELD_STRLIST,  False ),
    ( 'kill_services',   FIELD_STRLIST,  False ),
    ( 'gate_urls',       FIELD_STRLIST,  False ),
    ( 'impers_accounts', FIELD_STRLIST,  True ),
    ( 'note',            FIELD_TEXT,     True ),
]


def load_hash_list(file_name):
    """Load hash list"""

    try:

        with io.open(file_name, 'rt', encoding='utf-8') as f:
            str_list = f.read().splitlines()

    except FileNotFoundError:

        return {}

    hash_list = {}

    for s in str_list:
        h = lb3_hash.get_wide_str_hash(s)
        hash_list[h] = s

    return hash_list


def get_cfg_pos(file_data):
    """Get configuration data position"""

    mz_sign, = struct.unpack_from('<H', file_data, 0)
    if (mz_sign != 0x5A4D):
        return None

    nt_hdr_pos, = struct.unpack_from('<L', file_data, 0x3C)

    pe_sign, = struct.unpack_from('<L', file_data, nt_hdr_pos)
    if (pe_sign != 0x00004550):
        return None

    # Parse PE header
    img_hdr_pos = nt_hdr_pos + 4
    num_sections, = struct.unpack_from('<H', file_data, img_hdr_pos + 2)
    opt_hdr_pos = img_hdr_pos + 0x14
    opt_hdr_size, = struct.unpack_from('<H', file_data, img_hdr_pos + 0x10)
    nt_hdr_size = 4 + 0x14 + opt_hdr_size
    first_section_hdr_pos = nt_hdr_pos + nt_hdr_size

    cfg_pos = None

    # Enumerate PE sections
    pos = first_section_hdr_pos

    for i in range(num_sections):

        s_name = file_data[pos : pos + 8]
        i = s_name.find(0)
        if (i >= 0):
            s_name = s_name[:i]

        s_pos, = struct.unpack_from('<L', file_data, pos + 20)

        if (s_pos != 0):
            if (s_name == CFG_SECTION_NAME):
                cfg_pos = s_pos
                break

        pos += 0x28

    return cfg_pos


def extract_helper_code(file_data, pos):
    """Extract helper code"""

    size, = struct.unpack_from('<L', file_data, pos)
    pos += 4
    data = bytearray(file_data[pos : pos + size])

    for i in range(len(data)):
        data[i] ^= 0x30

    return aplib.decompress(data)


def mkdirs(dir):
    """Create directory hierarchy"""

    try:
        os.makedirs(dir)

    except OSError as exception:
        if (exception.errno != errno.EEXIST):
            raise


def save_data_to_file(file_name, data):
    """Save binary data to file."""
    with io.open(file_name, 'wb') as f:
        f.write(data)


#
# Main
#
if len(sys.argv) != 2:
    print('Usage: '+ sys.argv[0] + ' filename')
    sys.exit(0)

file_name = sys.argv[1]

# Load file data
with io.open(file_name, 'rb') as f:
    file_data = f.read()

# Load hash list
hash_list = load_hash_list('strings.txt')

# Extract helper code
helper_code = extract_helper_code(file_data, ENC_HELPER_CODE_POS)

dest_dir = os.path.abspath(os.path.dirname(file_name)) + '/cfg/'
mkdirs(dest_dir)

save_data_to_file(dest_dir + 'helper_code.bin', helper_code)
print('helper code saved to file.')

# Extract configuration data
cfg_pos = CFG_POS
if cfg_pos is None:
    cfg_pos = get_cfg_pos(file_data)
    if cfg_pos is None:
        print('Error: LockBit 3.0 configuration data not found.')

print('configuration data position: %08X' % cfg_pos)

rnd_seed, = struct.unpack_from('<Q', file_data, cfg_pos)
print(('rnd seed: %08X') % rnd_seed)

cfg_pos += 8

pack_cfg_data_size, = struct.unpack_from('<L', file_data, cfg_pos)
print('compressed cfg data size: %d' % pack_cfg_data_size)

cfg_pos += 4

enc_cfg_data = file_data[cfg_pos : cfg_pos + pack_cfg_data_size]

pack_cfg_data = lb3_dec.decrypt(helper_code, enc_cfg_data, rnd_seed)

cfg_data = aplib.decompress(pack_cfg_data)

print('cfg data size: %d' % len(cfg_data))

save_data_to_file(dest_dir + 'cfg_data.bin', cfg_data)
print('cfg data saved to file.')

pos = 0

# RSA public key
rsa_pub_key = cfg_data[pos : pos + RSA_PUB_KEY_SIZE]
save_data_to_file(dest_dir + 'rsa_pub_key.bin', rsa_pub_key)
print('RSA public key saved to file.')

pos += RSA_PUB_KEY_SIZE

config = {}

bot = {}

# UID
uid = binascii.hexlify(cfg_data[pos : pos + UID_SIZE]).decode()
bot['uid'] = uid
print('uid: \"%s\"' % uid)

pos += UID_SIZE

# AES key
bot['key'] = binascii.hexlify(cfg_data[pos : pos + AES_KEY_SIZE]).decode()

pos += AES_KEY_SIZE

config['bot'] = bot

cfg = {}

# Settings
settings = {}

for setting in SETTINGS:

    if setting[1] == SETTING_BOOL:

        settings[setting[0]] = (cfg_data[pos] != 0)
        pos += 1

    elif setting[1] == SETTING_WORD:

        settings[setting[0]], = struct.unpack_from('<H', cfg_data, pos)
        pos += 2

    elif setting[1] == SETTING_ENC_MODE:

        enc_mode = ENC_MODES.get(cfg_data[pos])
        if enc_mode is not None:
            settings[setting[0]] = enc_mode
        else:
            settings[setting[0]] = cfg_data[pos]
        pos += 1

    else:
        settings[setting[0]] = cfg_data[pos]
        pos += 1

cfg['settings'] = settings

# Fields
data_pos = pos

for fld in FIELDS:

    if fld[1] != FIELD_UNKNOWN:

        ofs, = struct.unpack_from('<L', cfg_data, pos)

        fld_data = ''

        if (ofs != 0):

            i = cfg_data.find(0, data_pos + ofs)
            if (i >= 0):
                b64_data = cfg_data[data_pos + ofs : i]
            else:
                b64_data = cfg_data[data_pos + ofs:]

            data = base64.decodebytes(b64_data)

            if fld[2]:
                data = lb3_dec.decrypt(helper_code, data, rnd_seed)

            if fld[1] == FIELD_HASHLIST:

                for i in range(0, len(data), 4):

                    h, = struct.unpack_from('<L', data, i)
                    if h == 0:
                        break

                    if fld_data != '':
                        fld_data += ';'
                    s = hash_list.get(h)
                    fld_data += s if (s is not None) else ('0x%08X' % h)

            if fld[1] == FIELD_STRLIST:

                fld_data = data.decode('utf-16le')
                str_list = list(filter(None, fld_data.split('\0')))
                fld_data = ';'.join(str_list)

            elif fld[1] == FIELD_TEXT:

                fld_data = data.decode()

            if fld[0] == 'note':
                save_data_to_file(dest_dir + 'ransom_note.txt', data)
                print('ransom note saved to file.')

        cfg[fld[0]] = fld_data

    pos += 4

config['config'] = cfg

# Save configuration data
with io.open(dest_dir + 'config.json', 'w', encoding='utf-8') as f:
    json.dump(config, f, ensure_ascii = False, indent=2)
